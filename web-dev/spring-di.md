# 스프링 의존성 주입과 제어 역전 기능

의존성 주입이란 사용할 클래스와 사용될 클래스의 관계를 개발자가 직접 코딩을 통해 컴포넌트(클래스)에 부여하는 것이 아니라 컨테이너가 연관 관계를 직접 규정하는 것입니다. 그러면 코드에서 직접적인 연관 관계가 발생하지 않으므로 각 클래스들의 변경이 자유로워집니다. (loosely coupled, 약한 결합)

전체 애플리케이션은 각각의 기능을 담당하는 컴퓨넌트들로 이루어집니다. 그리고 각 컴포넌트들은 다시 세부 기능을 수행하는 클래스들로 이루어집니다. 그런데 컴포넌트를 이루는 클래스들이 다른 클래스의 기능을 사용하려면 어떻게 해야 할까요? 소스 코드에서 다른 클래스의 생성자를 호출해서 사용할 경우 기능을 구현하는 과정에서 다른 변경 사항이 발생하면 빠르게 대처하기가 어렵습니다. 또다시 관련이 있는 모든 클래스들의 소스 코드를 수정해 주어야 하기 때문입니다.

따라서 스프링 프레임워크에서는 각 클래스들의 연관 관계를 클래스들 사이에서 맺는 것이 아니라 스프링 프레임워크에서 설정을 통해 맺어줌으로써 클래스들이 연관 관계를 갖지 않게 구현했습니다.

&nbsp;

## 의존성 주입을 적용했을 때 얻을 수 있는 장점

- 클래스들 간의 의존 관계를 최소화하여 코드를 단순화할 수 있다.
- 애플리케이션을 더 쉽게 유지 및 관리할 수 있다.
- 기존 구현 방법은 개발자가 직접 코드 안에서 객체의 생성과 소멸을 제어했다. 하지만 의존성 주입은 객체의 생성, 소멸과 객체 간의 의존 관계를 컨테이너가 제어.

&nbsp;

## 의존성 주입과 제어의 역전

의존성 주입은 객체의 생성, 소멸, 의존 관계를 개발자가 직접 설정하는 것이 아니라 XML이나 애너테이션 설정을 통해 경량 컨테이너에 해당하는 스프링 프레임워크가 제어합니다. 따라서 기존 코드에서는 개발자가 직접 객체를 제어했지만 스프링 프레임워크에서는 객체의 제어를 스프링이 직접 담당하므로 제어의 역전(IoC)이라고 하는 것입니다. IoC의 종류도 여러 가지이며, 일반적으로 스프링에서는 DI로 IoC의 기능을 구현하므로 IoC보다는 DI라는 용어를 더 많이 사용합니다.

```java
// 생성자를 이용한 DI
public class BoardServiceImpl implements BoardService {
    private BoardDAO boardDAO;
    public BoardServiceImpl() {
        boardDAO = new BoardDAOImpl();
    }
}

// setter를 이용한 DI
public class BoardServiceImpl implements BoardService {
    private BoardDAO boardDAO;
    public void setBoardDAO(BoardDAO boardDAO) {
        this.boardDAO = boardDAO;
    }
}
```

BoardSerivceImpl 클래스는 의존하는 BoardDAOImpl 객체를 전달받기 위해 new 키워드를 사용해 객체를 생성하지 않고 생성자를 호출할 때 외부에서 객체를 주입 받아 사용했습니다. 소스 코드에서 new를 사용해 객체를 생성하는 것이 아니라 BoardServiceImpl 생성자를 호출할 때 컨테이너에 의해 주입되는 객체로 boardDAO 변수를 초기화한 것입니다.

스프링에서는 의존(dependency)하는 객체를 컨테이너 실행 시 주입(inject)하기 때문에 의존성 주입(Dependency Injection)이라고 부릅니다. 여기서 각 클래스 객체를 bean이라고 부르는데, 이는 의존 관계를 설정하는 외부 XML 파일에서 각각의 객체를 \<bean\> 태그로 표시하기 때문입니다.

&nbsp;

Excerpt From <자바 웹을 다루는 기술> by 이병승